-----PASTE SCRIPTS BELOW THIS LINE DO NOT TOUCH ANY OF THE CODE ABOVE THIS LINE
warn("Polygoner fixed by basstracker1970")
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

local GYRO = nil
local PLAYER = game.Players.LocalPlayer
CurrentCF = Player.Character.HumanoidRootPart.CFrame
CurrentChar = Player.Character
newChar = script.Polygoner
newChar.Parent = workspace
newChar.Name = CurrentChar.Name
newChar.HumanoidRootPart.CFrame = CurrentCF
Player.Character = newChar
script.Parent = newChar
CurrentChar:Destroy()
local CHARACTER = Player.Character
local HUMANOID = CHARACTER.Polygoner
local TORSO = CHARACTER.Torso
local ROOT = CHARACTER.HumanoidRootPart
local RIGHTARM = CHARACTER["Right Arm"]
local LEFTARM = CHARACTER["Left Arm"]
local RIGHTLEG = CHARACTER["Right Leg"]
local LEFTLEG = CHARACTER["Left Leg"]
local AXE = CHARACTER.Axe
RootJoint = ROOT["Root"]
Neck = TORSO["Head"]
RightShoulder = TORSO["RArm"]
LeftShoulder = TORSO["LArm"]
RightHip = TORSO["RLeg"]
LeftHip = TORSO["LLeg"]
Grab = RIGHTARM.Grasp
local BODY = {}
for index, CHILD in pairs(CHARACTER:GetDescendants()) do
	if CHILD:IsA("BasePart") or CHILD:IsA("JointInstance") then
		table.insert(BODY,{CHILD,CHILD.Parent})
	end
end
local ATTACKING = false
local MUSIC = script.PolyTheme
MUSIC:Play()
local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}
if script:FindFirstChild("Color") then

end
local CLONE = CHARACTER:Clone()
CLONE.Parent = nil
CHARACTER.Archivable = false

Debris = game:GetService("Debris")

local Effects = IT("Folder",CHARACTER)

--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = 1/60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

--//=================================\\
--|| 			FUNCTIONS
--\\=================================//

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = TORSO.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local function weldBetween(a, b)
	local weldd = IT("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CF()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

--//=================================\\
--|| 		   CLERPING
--\\=================================//

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end

function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end

function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function ClerpBody(TABLE,PRIORITY)
	if PRIORITY == "Attack" or ATTACKING == false then
		RootJoint.C1 = Clerp(RootJoint.C1, TABLE[1], 0.35)
		Neck.C1 = Clerp(Neck.C1, TABLE[2], 0.35)
		RightShoulder.C1 = Clerp(RightShoulder.C1, TABLE[3], 0.35)
		LeftShoulder.C1 = Clerp(LeftShoulder.C1, TABLE[4], 0.35)
		RightHip.C1 = Clerp(RightHip.C1, TABLE[5], 0.35)
		LeftHip.C1 = Clerp(LeftHip.C1, TABLE[6], 0.35)
		Grab.C0 = Clerp(Grab.C0, TABLE[7], 0.35)
	end
end

function SpawnPuddle(POSITION,IGNR,GOO)
	local HIT,POS,NOR = Raycast(POSITION, CFrame.new(POSITION,POSITION-Vector3.new(0,1,0)).lookVector, 12, IGNR)
	if HIT then
		coroutine.resume(coroutine.create(function()
			local GOREPART = CreatePart(3, Effects, "Slate", 0, 1, "Pearl", "Gore", VT(3,0,3), true)
			local SURFACE = script.PuddleSurface:Clone()
			SURFACE.Parent = GOREPART
			if GOO == true then
				SURFACE.Image.ImageColor3 = C3(0,0,0)
			end
			GOREPART.CFrame = CFrame.new(POS,POS+NOR)*CFrame.Angles(math.rad(-90),math.rad(math.random(0,360)),0)
			for i = 1, math.random(25,65) do
				wait()
				GOREPART.Size = GOREPART.Size + Vector3.new(0.1,0,0.1)
			end
			wait(math.random(10,25)/10)
			for i = 1, 25 do
				wait()
				SURFACE.Image.ImageTransparency = SURFACE.Image.ImageTransparency + 1/25
			end
			GOREPART:Remove()
		end))
	end
end

--//=================================\\
--|| 	ATRIFICIAL INTELLIGENCE
--\\=================================//

function Execute(TARGET)
	for i = 1, 5 do
		Swait()
		ClerpBody({
			CF(0,0.2,0)*ANGLES(0,RAD(15),0),
			CF(0,-1.5,0)*ANGLES(RAD(-15),-RAD(15),0),
			CF(-1.5,0.75,0)*ANGLES(0,RAD(-15),RAD(-90))*CF(-1,0,0),
			CF(1.5,0.5,0)*ANGLES(RAD(-115),RAD(-15),0)*CF(0,-0.5,0),
			CF(-0.55,2,0.35)*ANGLES(0,RAD(-5),0)*ANGLES(0,0,0),
			CF(0.65,2,0.35)*ANGLES(0,RAD(-20),0)*ANGLES(0,0,0),
			CF(0,0,0)
		},nil)
	end
	ATTACKING = true
	TARGET:BreakJoints()
	local PRIMARY = TARGET:FindFirstChild("UpperTorso") or TARGET:FindFirstChild("Torso")
	if PRIMARY then
		local Spill = function(PART)
			if PART then
				coroutine.resume(coroutine.create(function()
					repeat
						Swait(MRANDOM(5,12))
						SpawnPuddle(PART.CFrame*CF(0,PART.Size.Y/2,0).p,Effects,false)
					until PART:FindFirstAncestor("Workspace") == nil
				end))
			end
		end
		CreateSound(566593606, PRIMARY, 5, 1, false)
		CreateSound(356551938, PRIMARY, 5, 1, false)
		TARGET.Parent = Effects
		if TARGET:FindFirstChild("UpperTorso") then
			local RAGDOLLER = script.R15Ragdoll:Clone()
			RAGDOLLER.Parent = TARGET
			RAGDOLLER.Disabled = false
			local FOUNTAIN = IT("Attachment",TARGET:FindFirstChild("UpperTorso"))
			FOUNTAIN.Name = "LostNeck"
			FOUNTAIN.Position = VT(0,TARGET:FindFirstChild("UpperTorso").Size.Y/2,0)
			local BLOOD = script.Fountain:Clone()
			BLOOD.Parent = FOUNTAIN
			BLOOD.Enabled = true
			Spill(TARGET.UpperTorso)
		else
			local RAGDOLLER = script.R6Ragdoll:Clone()
			RAGDOLLER.Parent = TARGET
			RAGDOLLER.Disabled = false
			local FOUNTAIN = IT("Attachment",TARGET:FindFirstChild("Torso"))
			FOUNTAIN.Name = "LostNeck"
			FOUNTAIN.Position = VT(0,TARGET:FindFirstChild("Torso").Size.Y/2,0)
			local BLOOD = script.Fountain:Clone()
			BLOOD.Parent = FOUNTAIN
			BLOOD.Enabled = true
			Spill(TARGET.Torso)
		end
		local BASE = TARGET:FindFirstChild("HumanoidRootPart")
		if BASE then
			TARGET:FindFirstChild("HumanoidRootPart"):Remove()
		end
		Debris:AddItem(TARGET,5)
		local OFFICIALLYDEAD = IT("Folder",TARGET)
		OFFICIALLYDEAD.Name = "Polygoner_Slain"
		for i = 1, 25 do
			Swait()
			ClerpBody({
				CF(0,0,0)*ANGLES(0,RAD(-45),0),
				CF(0,-1.5,0)*ANGLES(RAD(15),RAD(25),0),
				CF(-2,0.65,-1)*ANGLES(0,0,RAD(90))*ANGLES(RAD(-15),0,RAD(15))*CF(-1,0,0.5)*ANGLES(RAD(180),0,0)*CF(-0.5,1,1.5)*ANGLES(0,0,0),
				CF(1.5,0,0),
				CF(-0.5,2,0)*ANGLES(0,RAD(5),0),
				CF(0.5,2,0.5)*ANGLES(RAD(10),RAD(-15),0),
				CF(0,0,0)*ANGLES(RAD(75),0,0)*CF(0,0.5,0)
			},"Attack")
		end
		coroutine.resume(coroutine.create(function()
			repeat wait() until ROOT.Kill.Playing == false
			ROOT.Taunt:Play()
		end))
	end
	ATTACKING = false
end

function Chatter()
	local CHAT = true
	local CHATTERS = {}
	for index, CHILD in pairs(ROOT:GetChildren()) do
		if CHILD:IsA("Sound") then
			if CHILD.Playing == true then
				CHAT = false
				break
			else
				if CHILD.Name == "Chatter" then 
					table.insert(CHATTERS,CHILD)
				end
			end
		end
	end
	if CHAT == true then
		CHATTERS[MRANDOM(1,#CHATTERS)]:Play()
	end
end

function TestForTarget(PRT,target)
	local to = true
	if PRT then
		if PRT:FindFirstAncestorOfClass("Model") == target.Parent then
			to = false
		end
	end
	return to
end

--//=================================\\
--|| 			WRAP
--\\=================================//

function BEGINAI()

	local ANIM = "Idle"
	HUMANOID.Running:connect(function(speed)
		if speed > 0 then
			if HUMANOID.WalkSpeed < 20 then
				ANIM = "Walk"
			else
				ANIM = "Run"
			end
		else
			ANIM = "Idle"
		end
	end)
	coroutine.resume(coroutine.create(function()
		local SINE = 0
		game:GetService("RunService").Heartbeat:connect(function()
			for index, CHILD in pairs(game.Players:GetPlayers()) do

				if CHILD.Character and CHILD.Name ~= script.Parent.Name then
					local AVATAR = CHILD.Character
					local ROOT2 = AVATAR.PrimaryPart
					local HUM = AVATAR:FindFirstChildOfClass("Humanoid")
					if ROOT2 and HUM then
						local DIST = (ROOT2.Position - ROOT.Position).Magnitude
						if DIST <= 100 then
							local STATIC = nil
							local POWER = math.ceil((100 - DIST))
							HUM.CameraOffset = VT(MRANDOM(-POWER,POWER),MRANDOM(-POWER,POWER),MRANDOM(-POWER,POWER))/100
							if CHILD.PlayerGui:FindFirstChild("GonerStatic") then
								STATIC = CHILD.PlayerGui:FindFirstChild("GonerStatic")
								STATIC.Static.ImageTransparency = (100-(POWER/4))/100
								STATIC.Script.Static.Volume = POWER/10
							else
								STATIC = script.GonerStatic:Clone()
								STATIC.Parent = CHILD.PlayerGui
								STATIC.Script.Disabled = false
								STATIC.Static.ImageTransparency = (100-(POWER/4))/100
								local SOUND = script.Static:Clone()
								SOUND.Parent = STATIC.Script
								SOUND.Volume = POWER/10
								local DIE = script.Taunt:Clone()
								DIE.Parent = STATIC.Script
							end
						else
							if CHILD.PlayerGui:FindFirstChild("GonerStatic") then
								CHILD.PlayerGui:FindFirstChild("GonerStatic"):Remove()
							end
							HUM.CameraOffset = VT(0,0,0)
						end
					end
				end
			end
			local DEFAULTS = {
				CF(0,0,0),
				CF(0,-1.5,0),
				CF(-1.5,0,0),
				CF(1.5,0,0),
				CF(-0.5,2,0),
				CF(0.5,2,0),
				CF(0,0,0)
			}
			SINE = SINE + 1
			local FLOOR = Raycast(ROOT.Position, (CF(ROOT.Position, ROOT.Position + VT(0, -1, 0))).lookVector, 5, CHARACTER)
			if FLOOR then
				if MRANDOM(1,5) == 1 then
					SpawnPuddle(ROOT.Position,CHARACTER,true)
				end
				if ANIM == "Idle" then
					AXE.Drag:Stop()
					ClerpBody({
						CF(0,0.1*COS(SINE/12),0)*ANGLES(0,RAD(15),0),
						CF(0,-1.5,0)*ANGLES(RAD(3*SIN(SINE/12)),RAD(-15),0),
						CF(-1.5,0.5-0.1*COS(SINE/12),0)*ANGLES(RAD(-15),RAD(-15),0)*CF(0,-0.5,0),
						CF(1.5,0,0),
						CF(-0.5,2-0.1*COS(SINE/12),0)*ANGLES(0,RAD(5),0),
						CF(0.5,2-0.1*COS(SINE/12),0.5)*ANGLES(RAD(10),RAD(-15),0),
						CF(0,0,0)
					},nil)
				elseif ANIM == "Walk" then
					AXE.Drag.Playing = true
					ClerpBody({
						CF(0,0.1*COS(SINE/5),0)*ANGLES(RAD(25),RAD(3*SIN(SINE/5)),0),
						CF(0,-1.5,0)*ANGLES(RAD(-15),RAD(3*SIN(SINE/10)),0),
						CF(0,0.5,0)*ANGLES(RAD(-40),RAD(35-3*SIN(SINE/5)),0)*CF(-1.5,-0.5,0),
						CF(1.5,0.5,0)*ANGLES(RAD(-15-(35*COS(SINE/10))),RAD(-15),0)*CF(0,0,0),
						CF(-0.5,2+0.35*SIN(SINE/10),0.3-0.3*SIN(SINE/10))*ANGLES(RAD(-15-(35*COS(SINE/10))),0,0),
						CF(0.5,2-0.35*SIN(SINE/10),0.3+0.3*SIN(SINE/10))*ANGLES(RAD(-15+(35*COS(SINE/10))),0,0),
						CF(0,0,0)
					},nil)
				elseif ANIM == "Run" then
					AXE.Drag.Playing = false
					ClerpBody({
						CF(0,0.2*COS(SINE/5),0)*ANGLES(RAD(25),RAD(15-3*SIN(SINE/5)),0),
						CF(0,-1.5,0)*ANGLES(RAD(-15),-RAD(15+3*SIN(SINE/10)),0),
						CF(-1.5,0.5,0)*ANGLES(0,RAD(35),RAD(-90))*CF(-1,0,0),
						CF(1.5,0.5,0)*ANGLES(RAD(-115),RAD(-15),0)*CF(0,-0.5,0),
						CF(-0.55,2+0.35*SIN(SINE/10),0.3-0.6*SIN(SINE/10))*ANGLES(0,RAD(-5),0)*ANGLES(RAD(-15-(45*COS(SINE/10))),0,0),
						CF(0.65,2-0.35*SIN(SINE/10),0.3+0.6*SIN(SINE/10))*ANGLES(0,RAD(-20),0)*ANGLES(RAD(-15+(45*COS(SINE/10))),0,0),
						CF(0,0,0)
					},nil)
				end
			else
				AXE.Drag:Stop()
				ClerpBody({
					CF(0,0,0)*ANGLES(RAD(-10),RAD(5),0),
					CF(0,-1.5,0)*ANGLES(RAD(15),RAD(-5),0),
					CF(-1.5,0,0.2)*ANGLES(RAD(-15),0,0),
					CF(1.5,-0.5,0)*ANGLES(RAD(-35),0,0)*CF(0,0.5,0),
					CF(-0.5,2,0.2)*ANGLES(RAD(10),RAD(-5),0),
					CF(0.5,1.5,1)*ANGLES(RAD(10),RAD(-15),0),
					CF(0,0,0)
				},nil)
			end
		end)
	end))
	HUMANOID.Died:Connect(function()
		CLONE.Parent = workspace
		CLONE:SetPrimaryPartCFrame(ROOT.CFrame)
		CLONE.PrimaryPart.Respawn:Play()
		CHARACTER:Destroy()
	end)
	local TARGET = nil
	local TARGETHUM = nil
	coroutine.resume(coroutine.create(function()
		coroutine.resume(coroutine.create(function()
			while wait(1) do
				local HITFACE = Raycast(ROOT.Position,ROOT.CFrame.lookVector,ROOT.Size.Z*2.5,CHARACTER)
				if HITFACE then
					if HITFACE.Anchored == true and HUMANOID.WalkSpeed > 0 and TARGETHUM then
						HUMANOID.Jump = true
					end
				end
			end
		end))
		local h = HUMANOID
		local pathService = game:GetService("PathfindingService")
		local Target = nil

		local closestTargetAndPath = function()
			local humanoids = {}
			for _,v in pairs(workspace:GetChildren()) do
				if v:findFirstChild("HumanoidRootPart") and v:findFirstChildOfClass("Humanoid") and v ~= CHARACTER and v:FindFirstChild("Slain") == nil then
					if v:findFirstChildOfClass("Humanoid").Health > 0 then
						table.insert(humanoids,v:findFirstChildOfClass("Humanoid"))
					end
				end
			end
			local closest,path,dist
			for _,humanoid in pairs(humanoids) do
				if humanoid.Torso then
					local myPath = pathService:ComputeRawPathAsync(h.Torso.Position,humanoid.Torso.Position,50)
					if myPath.Status ~= Enum.PathStatus.FailFinishNotEmpty then
						-- Now that we have a successful path, we need to figure out how far we need to actually travel to reach this point.
						local myDist = 0
						local previous = h.Torso.Position
						for _,point in pairs(myPath:GetPointCoordinates()) do
							myDist = myDist + (point-previous).magnitude
							previous = point
						end
						if not dist or myDist < dist then -- if true, this is the closest path so far.
							closest = humanoid
							path = myPath
							dist = myDist
						end
					end
				end
			end
			return closest,path
		end

		local goToPos = function(loc,target)
			---h:MoveTo(loc)
			local distance = (loc-h.Torso.Position).magnitude
			local start = tick()
			while distance > 4 do
				if target then
					if target.Torso then
						local RAYTEST = Raycast(ROOT.Position,CF(ROOT.Position,VT(target.Torso.Position.X,ROOT.Position.Y,target.Torso.Position.Z)).lookVector,500,CHARACTER)
						if tick()-start > distance/h.WalkSpeed or TARGETHUM ~= target then -- Something may have gone wrong. Just break.
							break
						end
						distance = (loc-ROOT.Position).magnitude
						Swait()
					else
						break
					end
				else
					break
				end
			end
		end

		while true do
			Swait()
			if GYRO == nil then
				local target,path = closestTargetAndPath()
				local didBreak = false
				local targetStart
				if target and h.Torso and target.Torso then
					Target = target
					targetStart = target.Torso.Position
					local previous = h.Torso.Position
					local points = path:GetWaypoints()
					local s = #points > 1 and 2 or 1
					for i = s,#points do
						if GYRO == nil then
							local point = points[i].Position
							if didBreak then 
								break
							end
							if target and target.Torso and target.Health > 0 then
								local RAYTEST = Raycast(ROOT.Position,CF(ROOT.Position,VT(target.Torso.Position.X,ROOT.Position.Y,target.Torso.Position.Z)).lookVector,500,CHARACTER)
								if (ROOT.Position - point).Magnitude > 1 and TestForTarget(RAYTEST,target) == true then
									local pos = previous:lerp(point,0.5)
									goToPos(previous:lerp(point,0.5),target)
									previous = point
								end
							else
								didBreak = true
								break
							end
						end
					end
				else
					Target = nil
				end
				if not didBreak and targetStart then
					goToPos(targetStart)
				end
			end
		end
	end))
	while true do
		local TARGETVARIANTS = {}
		TARGET = nil
		for index, CHILD in pairs(workspace:GetChildren()) do
			if CHILD ~= CHARACTER and CHILD:FindFirstChild("Polygoner_Slain") == nil then
				local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
				if HUMAN then
					if HUMAN.Health > 0 then
						if HUMAN.Torso then
							local DISTANCE = (HUMAN.Torso.Position - ROOT.Position).Magnitude
							table.insert(TARGETVARIANTS,{CHILD,DISTANCE})
						end
					end
				end
			end
		end
		local DIST = math.huge
		for E = 1, #TARGETVARIANTS do
			local PLAYER = TARGETVARIANTS[E]
			local CHARACTER = PLAYER[1]
			local DISTANCE = PLAYER[2]
			if DISTANCE < DIST then
				DIST = DISTANCE
				TARGET = CHARACTER
			end
		end
		if TARGET and TARGET:FindFirstChild("HumanoidRootPart") then
			TARGETHUM = TARGET:FindFirstChildOfClass("Humanoid")
			if DIST <= 45 or TARGET:FindFirstChild("Polygoner_Trigger") then
				if TARGET:FindFirstChild("Polygoner_Trigger") == nil then
					local GONE = IT("Folder",TARGET)
					GONE.Name = "Polygoner_Trigger"
				end
				MUSIC.Pitch = 0.5
				if HUMANOID.WalkSpeed == 12 then
					for index, CHILD in pairs(ROOT:GetChildren()) do
						if CHILD:IsA("Sound") then
							CHILD:Stop()
						end
					end
					ROOT.Kill:Play()
				end
				HUMANOID.WalkSpeed = TARGETHUM.WalkSpeed + 15
				if HUMANOID.WalkSpeed < 35 then
					HUMANOID.WalkSpeed = 35
				end
				if DIST <= 7 then
					HUMANOID.WalkSpeed = 0
					Execute(TARGET)
				end
			else
				if TARGETHUM.WalkSpeed > 16 then
					TARGETHUM.WalkSpeed = 16
				end
				MUSIC.Pitch = 0.35
				HUMANOID.WalkSpeed = 17
				if DIST <= 350 and MRANDOM(1,125) == 1 then
					Chatter()
				end
			end
		else
			TARGETHUM = nil
			MUSIC.Pitch = 0.35
		end
		wait()
	end
end

local player = game.Players.LocalPlayer
local camera = workspace.CurrentCamera
camera.CameraSubject = player.Character or player.CharacterAdded:Wait()

BEGINAI()

